//! Implementation of Schnorr Signature Scheme (a varient scheme by using elliptic curve cryptography)

use digest::Digest;
use p256::{
    elliptic_curve::{point::AffineCoordinates, Group, PrimeField},
    FieldBytes, NistP256,
};
use serde::{Deserialize, Serialize};
use std::ops::{Mul, Neg};

/// Schnorr Signature Scheme based on elliptic curve cryptography.
/// The scheme consists of the following steps:
/// 1. Generate a key pair (d, p) where p = -dG.
/// 2. Sign a message m with the key pair (d, p) by generating a random number k and calculate r = kG and e = H(r_x || p_x || m).
/// 3. Calculate s = k + e*d.
/// 4. The signature is (e, s).
/// 5. Verify the signature by calculating r_v = sG + eP and e_v = H(r_x || p_x || m). If e_v == e, then the signature is valid.
///
/// The scheme is based on the elliptic curve cryptography with the curve P-256.
/// The hash function H is used to hash a byte array into a 32-byte array.
#[derive(Default, Clone, Serialize, Deserialize)]
pub struct SignatureScheme<H: Digest> {
    /// generator point
    g: p256::AffinePoint,
    _phantom: std::marker::PhantomData<H>,
}

impl<H: Digest> SignatureScheme<H> {
    pub fn new() -> Self {
        Self {
            g: p256::ProjectivePoint::generator().to_affine(),
            _phantom: std::marker::PhantomData,
        }
    }

    /// Generate a key pair (d, p) where p = -dG.
    /// Return the signing key and public key.
    /// The signing key is used to sign a message (by calling [SignatureScheme::sign]),
    /// while the public key is used to verify the signature (by calling [SignatureScheme::verify]).
    /// The key pair is generated by using the random number generator rng.
    pub fn generate_key<R: rand::CryptoRng + rand::RngCore>(
        &self,
        rng: &mut R,
    ) -> (SigningKey, PublicKey) {
        // p = -dG
        let d = p256::NonZeroScalar::random(rng);
        let p = self.g.mul(d.neg().as_ref()).to_affine();
        (SigningKey { d }, PublicKey { p })
    }

    /// Sign a message m with the key pair (d, p) by generating a random number k and
    /// - calculate r = kG and e = H(r_x || p_x || m).
    /// - calculate s = k + e*d.
    ///
    /// Return the signature (e, s).
    ///
    /// The signature is used to verify the message (by calling [SignatureScheme::verify]), which
    /// is generated by using the random number generator rng.
    pub fn sign<R: rand::CryptoRng + rand::RngCore, M: AsRef<[u8]>>(
        &self,
        rng: &mut R,
        key: &SigningKey,
        pub_key: &PublicKey,
        message: M,
    ) -> Signature {
        // r = kG
        let k = p256::NonZeroScalar::random(rng);
        let r = self.g.mul(k.as_ref());

        // e = H(r_x || p_x || m)
        let r_x = r.to_affine().x().to_vec();
        let p_x = pub_key.p.x().to_vec();
        let e = p256::elliptic_curve::ScalarPrimitive::<p256::NistP256>::from_slice(
            &H::new()
                .chain_update([r_x, p_x, message.as_ref().to_vec()].concat())
                .finalize(),
        )
        .unwrap();
        let e = p256::Scalar::from(e);
        // s = k + e*d
        let s = k.add(&e.multiply(&key.d));
        Signature { e, s }
    }

    /// Verify the signature by calculating r_v = sG + eP and e_v = H(r_x || p_x || m).
    /// If e_v == e, then the signature is valid.
    /// Return true if the signature is valid, otherwise false.
    pub fn verify(&self, key: &PublicKey, message: &[u8], signature: &Signature) -> bool {
        // r_v = sG + eP
        let r_v = self
            .g
            .mul(signature.s.as_ref())
            .add(&key.p.mul(signature.e.as_ref()));
        // ev = H(r_x || p_x || m)
        let r_x = r_v.to_affine().x().to_vec();
        let p_x = key.p.x().to_vec();
        let e_v = p256::elliptic_curve::ScalarPrimitive::<p256::NistP256>::from_slice(
            &H::new()
                .chain_update([r_x, p_x, message.to_vec()].concat())
                .finalize(),
        );
        // if e_v == e, then the signature is valid\
        e_v.map(p256::Scalar::from)
            .map(|e_v| e_v == signature.e)
            .unwrap_or(false)
    }
}

/// Public key used to verify a signature.
#[derive(PartialEq, Eq, Clone, Serialize, Deserialize)]
pub struct PublicKey {
    p: p256::AffinePoint,
}

impl From<PublicKey> for Vec<u8> {
    fn from(key: PublicKey) -> Self {
        use p256::elliptic_curve::sec1::ToEncodedPoint;
        key.p.to_encoded_point(false).as_bytes().to_vec()
    }
}

impl TryFrom<&[u8]> for PublicKey {
    type Error = ();

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        use p256::elliptic_curve::sec1::FromEncodedPoint;
        p256::elliptic_curve::sec1::EncodedPoint::<NistP256>::from_bytes(value)
            .map_err(|_| ())
            .and_then(|p| {
                p256::AffinePoint::from_encoded_point(&p)
                    .into_option()
                    .ok_or(())
            })
            .map(|p| PublicKey { p })
    }
}

/// Signing key used to sign a message.
#[derive(Clone, Serialize, Deserialize)]
pub struct SigningKey {
    d: p256::NonZeroScalar,
}

impl From<SigningKey> for Vec<u8> {
    fn from(key: SigningKey) -> Self {
        key.d.to_bytes().as_slice().to_vec()
    }
}

impl TryFrom<&[u8]> for SigningKey {
    type Error = ();

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let d_bytes = FieldBytes::from_slice(value);
        let d = p256::NonZeroScalar::from_repr(*d_bytes)
            .into_option()
            .ok_or(())?;
        Ok(SigningKey { d })
    }
}

/// Signature used to verify a message.
#[derive(PartialEq, Eq, Clone, Serialize, Deserialize)]
pub struct Signature {
    e: p256::Scalar,
    s: p256::Scalar,
}

impl From<Signature> for Vec<u8> {
    fn from(signature: Signature) -> Self {
        [
            signature.e.to_bytes().as_slice(),
            signature.s.to_bytes().as_slice(),
        ]
        .concat()
    }
}

impl TryFrom<&[u8]> for Signature {
    type Error = ();

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        if value.len() != 64 {
            return Err(());
        }

        let e_bytes = FieldBytes::from_slice(&value[..32]);
        let s_bytes = FieldBytes::from_slice(&value[32..]);

        let e = p256::Scalar::from_repr(*e_bytes).into_option().ok_or(())?;
        let s = p256::Scalar::from_repr(*s_bytes).into_option().ok_or(())?;
        Ok(Signature { e, s })
    }
}

pub struct Signer<'a, H>
where
    H: Digest,
{
    pub key: &'a SigningKey,
    pub pub_key: &'a PublicKey,
    pub scheme: &'a SignatureScheme<H>,
}

impl<'a, H> signature::RandomizedDigestSigner<H, Vec<u8>> for Signer<'a, H>
where
    H: Digest,
{
    fn try_sign_digest_with_rng(
        &self,
        rng: &mut impl signature::rand_core::CryptoRngCore,
        digest: H,
    ) -> Result<Vec<u8>, signature::Error> {
        let message = digest.finalize();
        Ok(self
            .scheme
            .sign(rng, self.key, self.pub_key, message.as_slice())
            .into())
    }
}

pub struct Verifier<'a, H>
where
    H: Digest,
{
    pub key: &'a PublicKey,
    pub scheme: &'a SignatureScheme<H>,
}

impl<'a, H, T> signature::DigestVerifier<H, T> for Verifier<'a, H>
where
    H: Digest,
    T: AsRef<[u8]>,
{
    fn verify_digest(&self, digest: H, signature: &T) -> Result<(), signature::Error> {
        let signature =
            Signature::try_from(signature.as_ref()).map_err(|_| signature::Error::new())?;

        let hashed_bytes = digest.finalize();
        self.scheme
            .verify(self.key, &hashed_bytes, &signature)
            .then(|| ())
            .ok_or(signature::Error::new())
    }
}
